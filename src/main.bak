// src/main.cpp
/**
 * @file main.cpp
 * @brief Main application firmware for an ESP32-S3 based environmental and plant monitoring device.
 *
 * This firmware initializes various sensors, loads configuration, connects to WiFi,
 * periodically collects and sends data, and enters deep sleep.
 * It utilizes modularized functions for better organization.
 */

// --- Core Arduino and System Includes ---
#include <Arduino.h>

// --- Optional Debugging ---
#define ENABLE_DEBUG_SERIAL
// --------------------------

// --- Local Libraries (Project Specific Classes from lib/) ---
#include "DHT22Sensor.h"
#include "BH1750Sensor.h"
#include "MLX90640Sensor.h"
#include "OV2640Sensor.h"
#include "LEDStatus.h"
#include "DHT11Sensor.h"    
#include "FanController.h"
#include "WiFiManager.h"
#include "ErrorLogger.h" 
#include "API.h"

// --- New Modularized Helper Files (from src/) ---
#include "ConfigManager.h"    // For Config struct and config management functions
#include "SystemInit.h"       // For system initialization functions
#include "CycleController.h"  // For main loop cycle orchestration functions
#include "EnvironmentTasks.h" // For environmental data collection and sending
#include "ImageTasks.h"       // For image capture and sending

// --- Hardware Pin Definitions ---
// These are now used to instantiate sensor objects or passed to init functions
#define I2C_SDA_PIN 47 
#define I2C_SCL_PIN 21 
#define DHT_PIN 14
#define DHT11_INTERNAL_PIN 41 
#define RELAY_PIN 42  

// --- Global Object Instances ---

BH1750Sensor lightSensor(Wire); // Wire object is global from Arduino framework
MLX90640Sensor thermalSensor(Wire);
DHT22Sensor dhtSensor(DHT_PIN);
OV2640Sensor camera;
LEDStatus led;
WiFiManager wifiManager;
API* api_comm = nullptr;
DHT11Sensor dht_internal_sensor(DHT11_INTERNAL_PIN);
FanController fan_controller(RELAY_PIN, false);

// --- RTC Data for Sleep Management ---
RTC_DATA_ATTR bool fansWereActiveBeforeSleep = false; // Tracks fan state across sleep cycles
RTC_DATA_ATTR uint32_t nextDataCollectionTimestampS = 0; // Unix timestamp (seconds) for next main data collection


// =========================================================================
//                               SETUP FUNCTION                          
// =========================================================================
void setup() {
    // Initialize LED first for early visual feedback
    led.begin(); // Assuming led is global and LEDStatus::begin() exists
    led.setState(ALL_OK); // Initial state

    // Initialize Serial port for debugging
    initSerial_Sys(); // From SystemInit.cpp

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing Filesystem..."));
    #endif
    if (!initFilesystem()) { // LEDStatus is handled by main directly
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] CRITICAL: Filesystem initialization failed. Halting."));
        #endif
        led.setState(ERROR_DATA); // Or a more specific FS error state
        while(1) { delay(1000); } // Halt
    }

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Loading configuration..."));
    #endif
    loadConfigurationFromFile(); // From ConfigManager.cpp (this populates global 'config')

    // Set WiFi credentials in WiFiManager using the loaded 'config'
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println("[MainSetup] Setting WiFi credentials in WiFiManager for SSID: " + config.wifi_ssid);
    #endif
    wifiManager.setCredentials(config.wifi_ssid, config.wifi_pass);

    // Initialize API object AFTER config is loaded (config.apiBaseUrl etc. are needed)
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing API communication object..."));
    #endif
    api_comm = new API(config.apiBaseUrl,
                       config.apiActivatePath,
                       config.apiAuthPath,
                       config.apiRefreshTokenPath);
    if (api_comm == nullptr) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] CRITICAL: Failed to allocate memory for API object. Halting."));
        #endif
        led.setState(ERROR_AUTH); // Or a generic system error
        while(1) { delay(1000); }
    }
    
    // Set MAC address in API object
     #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Obtaining MAC Address..."));
    #endif
    String macAddr = wifiManager.getMacAddress(); 
    if (!macAddr.isEmpty()) {
        api_comm->setDeviceMAC(macAddr); 
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainSetup] MAC Address %s set in API object.\n", macAddr.c_str());
        #endif
    } else {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] WARNING: Could not obtain MAC address. Activation might require it."));
        #endif
    }

    // Initialize WiFi (sets mode, does not connect yet)
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing WiFiManager..."));
    #endif
    wifiManager.begin();

    // Initialize DHT11 sensor
     #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing Internal DHT11 Sensor..."));
    #endif
    dht_internal_sensor.begin(); 

    // Initialize FanController 
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing Fan Controller..."));
    #endif
    fan_controller.begin();

    // Initialize I2C bus
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing I2C bus..."));
    #endif
    initI2C_Sys(I2C_SDA_PIN, I2C_SCL_PIN); // From SystemInit.cpp, using defined pins

    // Initialize all connected hardware sensors
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing sensors..."));
    #endif
    if (!initializeSensors_Sys(dhtSensor, lightSensor, thermalSensor, camera)) { // From SystemInit.cpp
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] Sensor initialization failed."));
        #endif
        led.setState(ERROR_SENSOR);
        // handleSensorInitFailure_Sys will call deepSleep and not return
        handleSensorInitFailure_Sys(config.sleep_sec); // From SystemInit.cpp
    }

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("--------------------------------------"));
        Serial.println(F("[MainSetup] Device setup completed successfully."));
        Serial.println(F("--------------------------------------"));
    #endif
    led.setState(ALL_OK);
    delay(1000); // Brief delay showing OK status
}

// =========================================================================
// ===                            MAIN LOOP                              ===
// =========================================================================
void loop() {
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("\n======================================"));
        Serial.println(F("--- Starting New Operational Cycle ---"));
        Serial.printf("[MainLoop] Free Heap: %u bytes, Min Free Heap: %u bytes\n", ESP.getFreeHeap(), ESP.getMinFreeHeap());
        #ifdef BOARD_HAS_PSRAM
            if(psramFound()){
                Serial.printf("[MainLoop] Free PSRAM: %u bytes\n", ESP.getFreePsram());
            } else {
                Serial.println("[MainLoop] PSRAM not found/available at runtime.");
            }
        #else
            Serial.println("[MainLoop] PSRAM support not compiled in.");
        #endif
        Serial.println(F("======================================"));
    #endif

    ledBlink_Ctrl(led);

    bool cycleStatusOK = true;
    String logUrl = "";
    if (api_comm != nullptr) {
        logUrl = api_comm->getBaseApiUrl() + config.apiLogPath;
    } else {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] CRITICAL: api_comm is null. Halting."));
        #endif
        led.setState(ERROR_DATA);
        while(1) delay(1000);
    }

    // --- Read Internal Temperature and Humidity (for logging and fan control) ---
    float currentInternalTemp = dht_internal_sensor.readTemperature();
    float currentInternalHum = dht_internal_sensor.readHumidity();
    #ifdef ENABLE_DEBUG_SERIAL
        if (isnan(currentInternalTemp)) {
            Serial.println(F("[MainLoop] Failed to read internal temperature."));
        } else {
            Serial.printf("[MainLoop] Internal Temperature: %.2f C, Humidity: %.2f %%\n", currentInternalTemp, currentInternalHum);
        }
    #endif

    fan_controller.controlTemperature(currentInternalTemp);
    if (fan_controller.isOn()) {
        led.setState(TEMP_HIGH_FANS_ON);
    } else {
        if (!isnan(currentInternalTemp) && currentInternalTemp < INTERNAL_LOW_TEMP_OFF) {
            if (led.getCurrentState() != ERROR_WIFI && led.getCurrentState() != ERROR_AUTH && 
                led.getCurrentState() != ERROR_SEND && led.getCurrentState() != ERROR_DATA && 
                led.getCurrentState() != ERROR_SENSOR) { // Don't override critical errors
                 led.setState(TEMP_NORMAL_FANS_OFF);
            }
        }
    }

    // --- 1. Handle WiFi Connection ---
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainLoop] Step 1: Checking WiFi Connection..."));
    #endif
    wifiManager.handleWiFi();
    const unsigned long wifiConnectTimeout = 20000;
    if (!ensureWiFiConnected_Ctrl(wifiManager, led, wifiConnectTimeout)) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] WiFi connection failed. Logging and entering deep sleep."));
        #endif
        // Log WiFi failure, passing current internal temp/hum
        ErrorLogger::sendLog(logUrl, api_comm ? api_comm->getAccessToken() : "", LOG_TYPE_ERROR, 
                             "WiFi connection failed in main loop.", 
                             currentInternalTemp, currentInternalHum); // <-- Pass temp/hum
        prepareForSleep_Ctrl(false, led);
        deepSleep_Ctrl(60, &led);
        return;
    }
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainLoop] WiFi Connection OK."));
    #endif
    if (led.getCurrentState() == ERROR_WIFI || led.getCurrentState() == CONNECTING_WIFI) {
        if (!fan_controller.isOn() && (isnan(currentInternalTemp) || currentInternalTemp < INTERNAL_LOW_TEMP_OFF)) {
             if (led.getCurrentState() != ERROR_AUTH && /* other non-WiFi errors */
                 led.getCurrentState() != ERROR_SEND && led.getCurrentState() != ERROR_DATA &&
                 led.getCurrentState() != ERROR_SENSOR ) {
                led.setState(ALL_OK);
             }
        }
    }

    // --- 2. Handle API Activation and Authentication ---
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainLoop] Step 2: Handling API Activation & Authentication..."));
    #endif
    // Pass currentInternalTemp and currentInternalHum to the control function
    bool apiReady = handleApiAuthenticationAndActivation_Ctrl(config, *api_comm, led, 
                                                              currentInternalTemp, currentInternalHum); // <-- Pass temp/hum

    if (!apiReady) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] API not ready (activation/auth failed). Entering deep sleep."));
        #endif
        // Logging is handled within handleApiAuthenticationAndActivation_Ctrl
        prepareForSleep_Ctrl(false, led);
        unsigned long sleepDurSecsApi = api_comm->getDataCollectionTimeMinutes();
        if (sleepDurSecsApi <=0) sleepDurSecsApi = config.sleep_sec; else sleepDurSecsApi = (sleepDurSecsApi > 5 ? sleepDurSecsApi * 60 : 5 * 60);
        deepSleep_Ctrl(sleepDurSecsApi, &led);
        return;
    }
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainLoop] API Ready. AccessToken available."));
    #endif
    if (led.getCurrentState() != TEMP_HIGH_FANS_ON && led.getCurrentState() != TEMP_NORMAL_FANS_OFF) {
         if (led.getCurrentState() != ERROR_SEND && led.getCurrentState() != ERROR_DATA && 
             led.getCurrentState() != ERROR_SENSOR && led.getCurrentState() != ERROR_WIFI /* ERROR_WIFI already handled */ ) {
            led.setState(ALL_OK);
         }
    }


    // --- Main Data Collection and Sending Logic (conditionally executed) ---
    uint32_t currentTimestampS = esp_timer_get_time() / 1000000ULL;
    bool performMainDataTasks = false;

    if (nextDataCollectionTimestampS == 0 || currentTimestampS >= nextDataCollectionTimestampS) {
        performMainDataTasks = true;
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Scheduled data collection time reached (current: %u, next: %u).\n", currentTimestampS, nextDataCollectionTimestampS);
        #endif
    } else {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Not yet time for scheduled data collection (current: %u, next: %u, diff: %u s).\n",
                          currentTimestampS, nextDataCollectionTimestampS, nextDataCollectionTimestampS - currentTimestampS);
        #endif
    }

    uint8_t* localJpegImage = nullptr;
    size_t localJpegLength = 0;
    float* localThermalData = nullptr;

    if (performMainDataTasks) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] --- Performing Main Data Collection Cycle ---"));
        #endif

        // --- 3. Perform Environmental Data Tasks ---
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] Step 3: Performing Environment Data Tasks..."));
        #endif
        // Pass currentInternalTemp and currentInternalHum
        if (!performEnvironmentTasks_Env(config, *api_comm, lightSensor, dhtSensor, led, 
                                         currentInternalTemp, currentInternalHum)) { // <-- Pass temp/hum
            cycleStatusOK = false;
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.println(F("[MainLoop] Environment data tasks FAILED."));
            #endif
        } else {
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.println(F("[MainLoop] Environment data tasks SUCCEEDED."));
            #endif
        }

        if (cycleStatusOK) {
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.println(F("[MainLoop] Step 4: Performing Image Data Tasks..."));
            #endif
            // Pass currentInternalTemp and currentInternalHum
            if (!performImageTasks_Img(config, *api_comm, camera, thermalSensor, led,
                                       &localJpegImage, localJpegLength, &localThermalData, 
                                       currentInternalTemp, currentInternalHum)) { // <-- Pass temp/hum
                cycleStatusOK = false;
                #ifdef ENABLE_DEBUG_SERIAL
                    Serial.println(F("[MainLoop] Image data tasks FAILED."));
                #endif
            } else {
                #ifdef ENABLE_DEBUG_SERIAL
                    Serial.println(F("[MainLoop] Image data tasks SUCCEEDED."));
                #endif
            }
        } else {
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.println(F("[MainLoop] Skipping Image Data Tasks due to previous failure in cycle."));
            #endif
        }

        unsigned long collectionIntervalMinutes = api_comm->getDataCollectionTimeMinutes();
        if (collectionIntervalMinutes == 0) collectionIntervalMinutes = DEFAULT_DATA_COLLECTION_MINUTES;
        nextDataCollectionTimestampS = currentTimestampS + (collectionIntervalMinutes * 60);
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Next main data collection scheduled for timestamp: %u (%lu minutes from now).\n",
                          nextDataCollectionTimestampS, collectionIntervalMinutes);
        #endif

    }

    if (localJpegImage != nullptr || localThermalData != nullptr) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] Step 5: Cleaning up image resources..."));
        #endif
        cleanupResources_Ctrl(localJpegImage, localThermalData, camera);
        localJpegImage = nullptr;
        localThermalData = nullptr;
    }

    if (performMainDataTasks) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] Step 6: Logging main data cycle status..."));
        #endif
        if (!logUrl.isEmpty() && api_comm && !api_comm->getAccessToken().isEmpty()) {
            if (cycleStatusOK) {
                ErrorLogger::sendLog(logUrl, api_comm->getAccessToken(), LOG_TYPE_INFO, 
                                     "Main data collection cycle completed successfully.", 
                                     currentInternalTemp, currentInternalHum); // <-- temp/hum already here
            } else {
                ErrorLogger::sendLog(logUrl, api_comm->getAccessToken(), LOG_TYPE_WARNING, 
                                     "Main data collection cycle completed with errors.", 
                                     currentInternalTemp, currentInternalHum); // <-- temp/hum already here
            }
        }
    }

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainLoop] Step 7: Preparing for Deep Sleep & Determining Duration..."));
    #endif
    prepareForSleep_Ctrl(cycleStatusOK, led);

    unsigned long sleepDurationFinalS;
    if (fan_controller.isOn()) {
        sleepDurationFinalS = 3 * 60;
        fansWereActiveBeforeSleep = true; // Update RTC var based on current fan state BEFORE sleep
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Fans are ON. Short thermal check sleep: %lu s.\n", sleepDurationFinalS);
        #endif
    } else { // Fans are OFF
        // If fans were on before this wake cycle (checked by RTC var), and now they are off
        if (fansWereActiveBeforeSleep && (isnan(currentInternalTemp) || currentInternalTemp < INTERNAL_HIGH_TEMP_ON)) {
            sleepDurationFinalS = 5 * 60;
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.printf("[MainLoop] Fans just turned OFF (were active). Cooldown check sleep: %lu s.\n", sleepDurationFinalS);
            #endif
        } else {
            uint32_t secsToNextCollection = (nextDataCollectionTimestampS > currentTimestampS) ? (nextDataCollectionTimestampS - currentTimestampS) : 0;
            unsigned long regularThermalCheckSleepS = 10 * 60;

            if (secsToNextCollection > 0 && secsToNextCollection < regularThermalCheckSleepS) {
                sleepDurationFinalS = secsToNextCollection > 15 ? secsToNextCollection : 15;
            } else {
                sleepDurationFinalS = regularThermalCheckSleepS;
            }
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.printf("[MainLoop] Fans OFF. Regular/Pre-collection sleep: %lu s. (ToNextCollection: %u s)\n", sleepDurationFinalS, secsToNextCollection);
            #endif
        }
        fansWereActiveBeforeSleep = false; // Update RTC var as fans are currently off
    }

    if (sleepDurationFinalS < 15) {
        sleepDurationFinalS = 15;
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Adjusted sleep duration to minimum: %lu s.\n", sleepDurationFinalS);
        #endif
    }

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.printf("[MainLoop] Final determined sleep duration: %lu seconds.\n", sleepDurationFinalS);
    #endif
    deepSleep_Ctrl(sleepDurationFinalS, &led);
}