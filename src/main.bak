// src/main.cpp
/**
 * @file main.cpp
 * @brief Main application firmware for an ESP32-S3 based environmental and plant monitoring device.
 *
 * This firmware initializes various sensors, manages an SD card for logging and state,
 * synchronizes time via NTP, loads configuration, connects to WiFi,
 * periodically collects and sends data, manages internal temperature via fans
 * with pre-cooling logic for the MLX90640, and enters deep sleep.
 * It utilizes modularized functions for better organization.
 * All code, comments, and documentation are in English.
 */

// --- Core Arduino and System Includes ---
#include <Arduino.h>
#include "esp_sleep.h"
#include "nvs_flash.h" // For NVS (Non-Volatile Storage) initialization
#include "esp_timer.h" // For esp_timer_get_time()

// --- Local Libraries (Project Specific Classes from lib/) ---
#include "DHT22Sensor.h"
#include "BH1750Sensor.h"
#include "MLX90640Sensor.h"
#include "OV2640Sensor.h"
#include "LEDStatus.h"
#include "WiFiManager.h"
#include "API.h"
#include "DHT11Sensor.h"
#include "ErrorLogger.h"
#include "SDManager.h"      
#include "TimeManager.h"    
#include "FanController.h"  

// --- Modularized Helper Files (from src/) ---
#include "ConfigManager.h"  // For loading config.json from LittleFS
#include "SystemInit.h"     // For initializing serial, I2C, sensors
#include "CycleController.h"// For cycle utility functions
#include "EnvironmentTasks.h"// For environment data tasks
#include "ImageTasks.h"     // For image capture tasks

// --- Hardware Pin Definitions ---
#define I2C_SDA_PIN 47
#define I2C_SCL_PIN 21
#define DHT_EXTERNAL_PIN 14     // External DHT22 sensor pin
#define DHT11_INTERNAL_PIN 41   // Internal DHT11 sensor pin
#define FAN_RELAY_PIN 42        // Relay control pin for fans

// --- Fan Control Thresholds & Durations ---
#define TEMP_FANS_NORMAL_MAX_C          19.9f // Temp below which fans are definitely off (unless pre-cooling)
#define TEMP_FANS_PRECOOL_MIN_C         20.0f // Min temp for pre-cooling state
#define TEMP_FANS_PRECOOL_MAX_C         29.9f // Max temp for pre-cooling state
#define TEMP_FANS_CONTINUOUS_COOL_ON_C  30.0f // Temp above which fans run continuously
#define TEMP_FANS_CONTINUOUS_COOL_OFF_C 25.0f // Temp below which continuous cooling stops
#define PRECOOL_DURATION_S              (5 * 60) // 5 minutes for MLX90640 stabilization
#define FAN_MONITOR_DELAY_MS            5000     // 5 seconds between temp checks when fans are actively cooling

// --- Sleep Durations & Delays ---
#define MIN_SLEEP_S                     15  // Minimum sleep duration to prevent rapid loops
#define AWAKE_PROCESSING_TIME_ESTIMATE_S 90 // Estimated time in seconds for all awake tasks (WiFi, API, Sensors, SD ops)

// --- WiFi Connection Settings ---
#define WIFI_INITIAL_CONNECT_TIMEOUT_MS 30000UL // 30 seconds for initial WiFi connection
#define MIN_SLEEP_S_ON_WIFI_FAILURE     MIN_SLEEP_S 
#define COLOMBIA_GMT_OFFSET_SEC         (-5 * 3600L)
#define COLOMBIA_DAYLIGHT_OFFSET_SEC    0

// --- Global Object Instances ---
// 'config' is defined in ConfigManager.cpp and declared extern in ConfigManager.h
SDManager sdManager;
TimeManager timeManager;
LEDStatus led;
WiFiManager wifiManager;
API* api_comm = nullptr; // Initialized in setup after SDManager

DHT22Sensor dhtExternalSensor(DHT_EXTERNAL_PIN);
DHT11Sensor dhtInternalSensor(DHT11_INTERNAL_PIN); // For internal hardware temperature
BH1750Sensor lightSensor(Wire); // Wire is default I2C
MLX90640Sensor thermalSensor(Wire);
OV2640Sensor camera;
FanController fanController(FAN_RELAY_PIN, false); 

// --- RTC Data for Sleep Management & State Persistence ---
RTC_DATA_ATTR uint32_t nextMainDataCollectionDueTimeS_RTC = 0; // Uptime for next full data cycle
RTC_DATA_ATTR uint32_t ventilationPrecoolStartTimeS_RTC = 0;   // Uptime when pre-cooling for MLX started
RTC_DATA_ATTR bool precoolingIsActive_RTC = false;             // True if pre-cooling phase is active
RTC_DATA_ATTR bool continuousCoolingActive_RTC = false;        // True if fans are in continuous cooling mode (>30C)
RTC_DATA_ATTR bool sdUsageWarning90PercentSent = false;        // True if 90% SD usage warning was sent

// Enum for internal fan/cooling state management
enum class DeviceCoolingState {
    NORMAL_FANS_OFF,            // Temp < 20°C
    PRECOOL_MAY_BE_NEEDED,      // Temp 20°C - 29.9°C, pre-cool before MLX if data cycle
    CONTINUOUS_COOLING          // Temp >= 30°C, or >25°C if was already in continuous
};

// =========================================================================
// ===                           SETUP FUNCTION                          ===
// =========================================================================
void setup() {
    initSerial_Sys(); 

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing LED..."));
    #endif
    led.begin();
    led.setState(ALL_OK);

    // --- NUEVO: Inicialización de NVS ---
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing NVS..."));
    #endif
    esp_err_t ret_nvs = nvs_flash_init();
    if (ret_nvs == ESP_ERR_NVS_NO_FREE_PAGES || ret_nvs == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] NVS partition needs erase/format. Erasing..."));
        #endif
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret_nvs = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret_nvs);
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] NVS Initialized."));
    #endif
    // --- FIN NUEVO: Inicialización de NVS ---

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing LittleFS for config.json..."));
    #endif
    if (!initFilesystem()) { 
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] CRITICAL: LittleFS (for config.json) initialization failed. Halting."));
        #endif
        led.setState(ERROR_DATA); 
        while(1) { delay(1000); }
    }

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Loading configuration from config.json..."));
    #endif
    loadConfigurationFromFile(); 

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing SD Card..."));
    #endif
    if (!sdManager.begin()) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] CRITICAL: SD Card initialization failed. Halting."));
        #endif
        led.setState(ERROR_DATA); 
        while(1) { delay(1000); } 
    } else {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] SD Card initialized. Listing root directory:"));
            sdManager.listDir("/", 0);
            sdManager.manageAllStorage(timeManager); 
        #endif
    }

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing API communication object (with SDManager)..."));
    #endif
    // La inicialización de la clave AES (y por tanto NVS) ocurre dentro del constructor de API
    api_comm = new API(sdManager, config.apiBaseUrl,
                       config.apiActivatePath, config.apiAuthPath, config.apiRefreshTokenPath);
    if (api_comm == nullptr) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] CRITICAL: Failed to allocate memory for API object. Halting."));
        #endif
        // Usar logToSdOnly ya que la API no está disponible para enviar log.
        ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::ERROR, "API object allocation failed in setup.", NAN, NAN);
        led.setState(ERROR_AUTH); 
        while(1) { delay(1000); }
    }
    
    // --- MODIFICADO: Usar SystemInit para inicializar WiFi ---
    if (!initializeWiFi_Sys(wifiManager, led, config, api_comm, sdManager, timeManager, camera,
                                        WIFI_INITIAL_CONNECT_TIMEOUT_MS, MIN_SLEEP_S_ON_WIFI_FAILURE)) {
        // initializeWiFi_Sys maneja el deep sleep en fallo crítico, esta sección no debería alcanzarse.
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] CRITICAL: initializeWiFi_Sys returned failure but device did not sleep. Halting."));
        #endif
        while(true) { delay(1000); } 
    }
    // --- FIN MODIFICADO ---

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing Internal DHT11 Sensor..."));
    #endif
    dhtInternalSensor.begin();

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing Fan Controller..."));
    #endif
    fanController.begin(); 

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing I2C bus..."));
    #endif
    initI2C_Sys(I2C_SDA_PIN, I2C_SCL_PIN); 

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("[MainSetup] Initializing external sensors..."));
    #endif
    if (!initializeSensors_Sys(dhtExternalSensor, lightSensor, thermalSensor, camera)) { 
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] External sensor initialization failed."));
        #endif
        ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::ERROR, "External sensor init failed in setup.", NAN, NAN);
        led.setState(ERROR_SENSOR);
        handleSensorInitFailure_Sys(config.sleep_sec); 
    }
    
    // --- MODIFICADO: Usar SystemInit para inicializar NTP ---
    // Asume que WiFi ya está conectado por initializeWiFi_Sys
    initializeNTP_Sys(timeManager, sdManager, api_comm, config, 
                                  COLOMBIA_GMT_OFFSET_SEC, COLOMBIA_DAYLIGHT_OFFSET_SEC);
    // --- FIN MODIFICADO ---
    
    if (nextMainDataCollectionDueTimeS_RTC == 0) {
         #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainSetup] RTC target for sleep calc (nextMainDataCollectionDueTimeS_RTC) is 0. Full data cycle will run."));
         #endif
    }

    String setupCompleteMsg = "Device setup completed. Initial Time: " + timeManager.getCurrentTimestampString();
    // Log de setup completo
    if (api_comm && api_comm->isActivated()){ // Solo enviar a API si está activada
         ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(), LOG_TYPE_INFO, setupCompleteMsg, NAN, NAN);
    } else {
         ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::INFO, setupCompleteMsg, NAN, NAN);
    }
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("--------------------------------------"));
        Serial.println(setupCompleteMsg);
        Serial.println(F("--------------------------------------"));
    #endif
    led.setState(ALL_OK);
    delay(1000); 
}

//=========================================================================
// ===                            MAIN LOOP                              ===
// =========================================================================
void loop() {
    unsigned long cycleStartTimeMs = millis();
    uint32_t currentDeviceUptimeS_atLoopStart = esp_timer_get_time() / 1000000ULL; 
    bool cycleStatusOK = true;
    DeviceCoolingState currentCoolingState = DeviceCoolingState::NORMAL_FANS_OFF;
    unsigned long actualDataIntervalS; 
    uint32_t uptimeAfterMainTasksS = 0; 

    #ifdef ENABLE_DEBUG_SERIAL
        Serial.println(F("\n======================================"));
        Serial.printf("--- New Cycle Start (Uptime: %u s, RTC Next Due: %u s) ---\n", currentDeviceUptimeS_atLoopStart, nextMainDataCollectionDueTimeS_RTC);
        Serial.printf("[MainLoopStart] Current Time: %s\n", timeManager.getCurrentTimestampString().c_str());
        if(esp_spiram_is_initialized()) { 
          Serial.printf("[MainLoopStart] Free PSRAM: %u, Largest Block: %u\n", heap_caps_get_free_size(MALLOC_CAP_SPIRAM), heap_caps_get_largest_free_block(MALLOC_CAP_SPIRAM));
        } else {
          Serial.printf("[MainLoopStart] Free Heap: %u, Largest Block: %u\n", heap_caps_get_free_size(MALLOC_CAP_DEFAULT), heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT));
        }
    #endif

    // --- 1. Leer Temperatura Interna y Determinar Estado de Enfriamiento ---
    float internalTemp = dhtInternalSensor.readTemperature();
    float internalHum = dhtInternalSensor.readHumidity();

    if (isnan(internalTemp)) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] WARNING: Failed to read internal temperature. Fan control may be affected."));
        #endif
        // Usar logToSdOnly ya que es un fallo interno del sensor
        ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::WARNING, "Failed to read internal temp for fan control.", NAN, NAN); // NAN para temp ya que falló
        currentCoolingState = DeviceCoolingState::NORMAL_FANS_OFF; 
    } else {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Internal Temp: %.2f C, Hum: %.2f %%\n", internalTemp, internalHum);
        #endif
        if (continuousCoolingActive_RTC) { 
            if (internalTemp > TEMP_FANS_CONTINUOUS_COOL_OFF_C) {
                currentCoolingState = DeviceCoolingState::CONTINUOUS_COOLING;
            } else {
                currentCoolingState = DeviceCoolingState::NORMAL_FANS_OFF; 
                continuousCoolingActive_RTC = false; 
            }
        } else { 
            if (internalTemp >= TEMP_FANS_CONTINUOUS_COOL_ON_C) {
                currentCoolingState = DeviceCoolingState::CONTINUOUS_COOLING;
                continuousCoolingActive_RTC = true; 
            } else if (internalTemp >= TEMP_FANS_PRECOOL_MIN_C && internalTemp <= TEMP_FANS_PRECOOL_MAX_C) {
                currentCoolingState = DeviceCoolingState::PRECOOL_MAY_BE_NEEDED;
            } else { 
                currentCoolingState = DeviceCoolingState::NORMAL_FANS_OFF;
            }
        }
    }
    
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.printf("[MainLoop] Determined Cooling State: %d (0:OFF, 1:PRECOOL_MAYBE, 2:CONTINUOUS)\n", (int)currentCoolingState);
        Serial.printf("[MainLoop] Fan State: %s, PrecoolActiveRTC: %d, ContinuousCoolActiveRTC: %d\n",
                        fanController.isOn() ? "ON" : "OFF", precoolingIsActive_RTC, continuousCoolingActive_RTC);
    #endif

    // --- 2. Controlar Ventiladores basado en el estado (acciones inmediatas) ---
    if (currentCoolingState == DeviceCoolingState::CONTINUOUS_COOLING) {
        if (!fanController.isOn()) {
            fanController.turnOn();
            // Solo enviar a API si está activada y tenemos conexión
            if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED) {
                ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(), LOG_TYPE_INFO, "Fans ON: Continuous cooling mode activated.", internalTemp, internalHum);
            } else {
                ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::INFO, "Fans ON: Continuous cooling mode activated.", internalTemp, internalHum);
            }
        }
        led.setState(TEMP_HIGH_FANS_ON);
    } else if (currentCoolingState == DeviceCoolingState::NORMAL_FANS_OFF) {
        if (fanController.isOn() && !precoolingIsActive_RTC) { 
            fanController.turnOff();
            if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED) {
                ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(), LOG_TYPE_INFO, "Fans OFF: Temperature normal.", internalTemp, internalHum);
            } else {
                ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::INFO, "Fans OFF: Temperature normal.", internalTemp, internalHum);
            }
        }
        // Solo cambiar estado de LED si no estamos en pre-enfriamiento activo.
        // Y si el estado actual es TEMP_HIGH_FANS_ON, lo pasamos a normal.
        // Otros estados de error o de proceso (TAKING_DATA, SENDING_DATA) no se deberían sobreescribir aquí.
        if(led.getCurrentState() == TEMP_HIGH_FANS_ON && !precoolingIsActive_RTC) {
            led.setState(TEMP_NORMAL_FANS_OFF); 
        }
    }
    // Para PRECOOL_MAY_BE_NEEDED, la activación se maneja más adelante.

    // --- 3. Decidir si las Tareas Principales de Datos deben ejecutarse ---
    bool performMainDataTasksThisCycle = false;
    esp_sleep_wakeup_cause_t wakeup_cause = esp_sleep_get_wakeup_cause();
    uint32_t currentUptimeForTaskDecision = esp_timer_get_time() / 1000000ULL;

    if (wakeup_cause == ESP_SLEEP_WAKEUP_TIMER) {
        performMainDataTasksThisCycle = true;
    } else if (wakeup_cause == ESP_SLEEP_WAKEUP_UNDEFINED && nextMainDataCollectionDueTimeS_RTC == 0) {
        performMainDataTasksThisCycle = true;
    } else if (nextMainDataCollectionDueTimeS_RTC != 0 && currentUptimeForTaskDecision >= nextMainDataCollectionDueTimeS_RTC) {
        performMainDataTasksThisCycle = true;
    }
    
    #ifdef ENABLE_DEBUG_SERIAL
        Serial.printf("[MainLoop] Perform Main Data Tasks This Cycle decision: %s (WakeupCause: %d, Uptime: %u, RTC Due: %u)\n",
         performMainDataTasksThisCycle ? "Yes" : "No", wakeup_cause, currentUptimeForTaskDecision, nextMainDataCollectionDueTimeS_RTC);
    #endif

    // --- 4. Lógica de Pre-enfriamiento para MLX90640 (si las tareas de datos son necesarias) ---
    if (performMainDataTasksThisCycle && 
        (currentCoolingState == DeviceCoolingState::PRECOOL_MAY_BE_NEEDED || currentCoolingState == DeviceCoolingState::CONTINUOUS_COOLING)) {
        
        uint32_t currentUptimeForPrecool = esp_timer_get_time() / 1000000ULL;
        if (!precoolingIsActive_RTC) { 
            ventilationPrecoolStartTimeS_RTC = currentUptimeForPrecool;
            precoolingIsActive_RTC = true;
            if (!fanController.isOn()) {
                fanController.turnOn();
                 if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED) {
                    ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(), LOG_TYPE_INFO, "Fans ON: Starting MLX90640 pre-cooling.", internalTemp, internalHum);
                } else {
                    ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::INFO, "Fans ON: Starting MLX90640 pre-cooling.", internalTemp, internalHum);
                }
            }
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.printf("[MainLoop] MLX90640 Pre-cooling STARTED. Start time RTC: %u\n", ventilationPrecoolStartTimeS_RTC);
            #endif
        }
        // Cambiar estado del LED a TOMANDO_DATOS solo si no está ya en un estado de error o de ventilador encendido por alta temp.
        if(led.getCurrentState() != ERROR_WIFI && led.getCurrentState() != ERROR_AUTH && 
           led.getCurrentState() != ERROR_SENSOR && led.getCurrentState() != ERROR_DATA &&
           led.getCurrentState() != ERROR_SEND && led.getCurrentState() != TEMP_HIGH_FANS_ON) {
            led.setState(TEMP_HIGH_FANS_ON);
        }


        uint32_t elapsedPrecoolTimeS = currentUptimeForPrecool - ventilationPrecoolStartTimeS_RTC;
       if (elapsedPrecoolTimeS < PRECOOL_DURATION_S) {
            uint32_t remainingPrecoolS = PRECOOL_DURATION_S - elapsedPrecoolTimeS;
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.printf("[MainLoop] Pre-cooling in progress. %u s remaining. Using blocking delay().\n", remainingPrecoolS);
            #endif
            delay(remainingPrecoolS * 1000); 
        }
        led.setState(TEMP_NORMAL_FANS_OFF);
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] MLX90640 Pre-cooling COMPLETED (or was already done). Proceeding to data tasks."));
        #endif
    }

    // --- 5. Tareas Principales de Recolección y Envío de Datos ---
    if (performMainDataTasksThisCycle) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] --- Executing Main Data Collection & Sending Tasks ---"));
        #endif
        
        // Solo hacer blink si no estamos ya mostrando un error o estado crítico
        if(led.getCurrentState() != ERROR_WIFI && led.getCurrentState() != ERROR_AUTH && 
           led.getCurrentState() != ERROR_SENSOR && led.getCurrentState() != ERROR_DATA &&
           led.getCurrentState() != ERROR_SEND && led.getCurrentState() != TEMP_HIGH_FANS_ON) {
            ledBlink_Ctrl(led);
        }


        if (!ensureWiFiConnected_Ctrl(wifiManager, led, 20000)) { // Reintentar conexión WiFi (20s timeout)
            cycleStatusOK = false;
            ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(), LOG_TYPE_ERROR, "WiFi connection failed before data tasks.", internalTemp, internalHum);
        } else {
            // WiFi conectado, proceder con autenticación y tareas de datos
            if (!handleApiAuthenticationAndActivation_Ctrl(sdManager, timeManager, config, *api_comm, led, internalTemp, internalHum)) {
                cycleStatusOK = false; // Error ya logueado dentro de la función
            } else {
                // API Autenticada y activada
                if(led.getCurrentState() != ERROR_WIFI && led.getCurrentState() != ERROR_AUTH && 
                   led.getCurrentState() != ERROR_SENSOR && led.getCurrentState() != ERROR_DATA &&
                   led.getCurrentState() != ERROR_SEND && led.getCurrentState() != TEMP_HIGH_FANS_ON) {
                    led.setState(TAKING_DATA);
                }

                // Las funciones performEnvironmentTasks_Env y performImageTasks_Img ahora guardan en pending/archive
                if (!performEnvironmentTasks_Env(sdManager, timeManager, config, *api_comm, lightSensor, dhtExternalSensor, led, internalTemp, internalHum)) {
                    cycleStatusOK = false; // Error ya logueado dentro de la función
                }
                
                // Solo proceder con tareas de imagen si las ambientales fueron (razonablemente) ok o si el cycleStatusOK aún es true
                if (cycleStatusOK) {
                    uint8_t* localJpegImage = nullptr;
                    size_t localJpegLength = 0;
                    float* localThermalData = nullptr;
                    if (!performImageTasks_Img(sdManager, timeManager, config, *api_comm, camera, thermalSensor, led, 
                                               &localJpegImage, localJpegLength, &localThermalData, internalTemp, internalHum)) {
                        cycleStatusOK = false; // Error ya logueado dentro de la función
                    }
                    // La limpieza de buffers es crucial y debe hacerse siempre que se hayan podido asignar.
                    cleanupImageBuffers_Ctrl(localJpegImage, localThermalData);
                }
            }
        }
        
        uptimeAfterMainTasksS = esp_timer_get_time() / 1000000ULL; 

        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Main data tasks complete (Status: %s). Uptime after tasks: %u.\n",
                          cycleStatusOK ? "OK" : "FAILED", uptimeAfterMainTasksS);
        #endif
        
        // Apagar ventiladores si el pre-enfriamiento terminó y no estamos en modo continuo
        if(precoolingIsActive_RTC) {
            precoolingIsActive_RTC = false;
            ventilationPrecoolStartTimeS_RTC = 0; // Resetear el tiempo de inicio del pre-enfriamiento
            if (currentCoolingState != DeviceCoolingState::CONTINUOUS_COOLING) {
                if (fanController.isOn()) {
                    fanController.turnOff();
                    if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED) {
                        ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(), LOG_TYPE_INFO, "Fans OFF: Pre-cooling finished.", internalTemp, internalHum);
                    } else {
                        ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::INFO, "Fans OFF: Pre-cooling finished.", internalTemp, internalHum);
                    }

                    // Resetear LED si estaba en TAKING_DATA o TEMP_HIGH_FANS_ON y ahora la temperatura es normal
                     if(led.getCurrentState() == TAKING_DATA || led.getCurrentState() == TEMP_HIGH_FANS_ON) {
                        led.setState(TEMP_NORMAL_FANS_OFF); // O ALL_OK si es más apropiado
                    }
                }
            }
        }
        // Log del resultado del ciclo principal
        if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED) {
            ErrorLogger::sendLog(sdManager, timeManager, api_comm->getBaseApiUrl() + config.apiLogPath, api_comm->getAccessToken(),
                                cycleStatusOK ? LOG_TYPE_INFO : LOG_TYPE_WARNING,
                                cycleStatusOK ? "Main data cycle completed successfully." : "Main data cycle completed with errors.",
                                internalTemp, internalHum);
        } else {
             ErrorLogger::logToSdOnly(sdManager, timeManager, cycleStatusOK ? LogLevel::INFO : LogLevel::WARNING,
                                cycleStatusOK ? "Main data cycle completed successfully (offline)." : "Main data cycle completed with errors (offline).",
                                internalTemp, internalHum);
        }
    } // Fin de if (performMainDataTasksThisCycle)


    // --- Determinar intervalo de datos actual ---
    unsigned long apiMinutes = api_comm->getDataCollectionTimeMinutes(); // api_comm es un puntero
    if (api_comm && apiMinutes > 0) { // Verificar que api_comm no sea nullptr
        actualDataIntervalS = apiMinutes * 60UL;
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Using API data collection interval: %lu minutes (%lu seconds).\n", apiMinutes, actualDataIntervalS);
        #endif
    } else {
        actualDataIntervalS = (unsigned long)config.sleep_sec; 
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] API interval not available/zero or api_comm null, using config.sleep_sec: %lu seconds.\n", actualDataIntervalS);
        #endif
    }
    // Asegurar un intervalo mínimo práctico
    if (actualDataIntervalS < (MIN_SLEEP_S + AWAKE_PROCESSING_TIME_ESTIMATE_S / 2)) { 
        actualDataIntervalS = MIN_SLEEP_S + AWAKE_PROCESSING_TIME_ESTIMATE_S / 2;
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Adjusted actualDataIntervalS to minimum practical: %lu seconds.\n", actualDataIntervalS);
        #endif
    }
    // --- FIN DEL CÁLCULO DEL INTERVALO DE DATOS ACTUAL ---

    // Si las tareas principales se ejecutaron, calcular/actualizar nextMainDataCollectionDueTimeS_RTC
    if (performMainDataTasksThisCycle) {
        nextMainDataCollectionDueTimeS_RTC = uptimeAfterMainTasksS + actualDataIntervalS;
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Main data tasks were performed. Next collection RTC target set to: %u (UptimeAfterTasks: %u + Interval: %lu)\n",
                          nextMainDataCollectionDueTimeS_RTC, uptimeAfterMainTasksS, actualDataIntervalS);
        #endif
    }
    
    // --- NUEVO: Procesar datos pendientes de la SD ---
    // Solo si hay WiFi, la API está activada y api_comm es válido
    if (wifiManager.getConnectionStatus() == WiFiManager::CONNECTED && api_comm && api_comm->isActivated()) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.println(F("[MainLoop] Attempting to process pending API calls from SD..."));
        #endif
        if(sdManager.isSDAvailable()){ // Adicionalmente chequear si la SD está disponible
            if(sdManager.processPendingApiCalls(*api_comm, timeManager, config, internalTemp, internalHum)) {
                #ifdef ENABLE_DEBUG_SERIAL
                    Serial.println(F("[MainLoop] Finished processing some pending API calls."));
                #endif
            } else {
                #ifdef ENABLE_DEBUG_SERIAL
                    Serial.println(F("[MainLoop] No pending API calls processed or conditions not met.")); // Puede ser verboso
                #endif
            }
        } else {
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.println(F("[MainLoop] SD not available, cannot process pending calls."));
            #endif
        }
    }
    // --- FIN NUEVO ---
    
    // --- NUEVO: Gestionar almacenamiento de la SD y Alerta de Uso ---
    if (sdManager.isSDAvailable()) {
        sdManager.manageAllStorage(timeManager); // Llama a la gestión avanzada de almacenamiento

        uint64_t sdUsedBytesCurrent = 0; 
        uint64_t sdTotalBytesCurrent = 0;
        float usagePercent = sdManager.getUsageInfo(sdUsedBytesCurrent, sdTotalBytesCurrent);

        if (usagePercent >= 0.0f) { 
            if (usagePercent >= 90.0f) {
                if (!sdUsageWarning90PercentSent) {
                    String msg = "CRITICAL WARNING: SD Card usage at " + String(usagePercent, 1) + 
                                 "%. Used: " + String(sdUsedBytesCurrent / (1024*1024)) + "MB / " + 
                                 String(sdTotalBytesCurrent / (1024*1024)) + "MB.";
                    #ifdef ENABLE_DEBUG_SERIAL
                        Serial.println("[Main_SD_Alert] " + msg);
                    #endif
                    if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED){
                        ErrorLogger::sendLog(sdManager, timeManager, 
                                            api_comm->getBaseApiUrl() + config.apiLogPath, 
                                            api_comm->getAccessToken(), 
                                            LOG_TYPE_WARNING, msg, 
                                            internalTemp, internalHum);
                    } else {
                        ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::WARNING, msg + " (Offline)", internalTemp, internalHum);
                    }
                    sdUsageWarning90PercentSent = true;
                }
            } else if (usagePercent < 85.0f) { 
                if (sdUsageWarning90PercentSent) { // Solo loguear resolución si la advertencia fue enviada
                    String msg = "INFO: SD Card usage is now " + String(usagePercent, 1) + 
                                 "%. Storage warning condition resolved.";
                    #ifdef ENABLE_DEBUG_SERIAL
                        Serial.println("[Main_SD_Alert] " + msg);
                    #endif
                     if(api_comm && api_comm->isActivated() && wifiManager.getConnectionStatus() == WiFiManager::CONNECTED){
                        ErrorLogger::sendLog(sdManager, timeManager, 
                                            api_comm->getBaseApiUrl() + config.apiLogPath, 
                                            api_comm->getAccessToken(), 
                                            LOG_TYPE_INFO, msg, 
                                            internalTemp, internalHum);
                    } else {
                         ErrorLogger::logToSdOnly(sdManager, timeManager, LogLevel::INFO, msg + " (Offline)", internalTemp, internalHum);
                    }
                    sdUsageWarning90PercentSent = false; 
                }
            }
        }
    }
    // --- FIN NUEVO ---
    
    // --- MODIFICADO: Decisión de Sueño usando funciones de CycleController ---
    unsigned long currentCalculatedSleepDurationS; 
    uint32_t currentUptimeForSleepDecision = esp_timer_get_time() / 1000000ULL;

    if (continuousCoolingActive_RTC) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Continuous cooling active. Delaying for %lu ms instead of deep sleep.\n", (unsigned long)FAN_MONITOR_DELAY_MS);
        #endif
        delay(FAN_MONITOR_DELAY_MS);
        return; // Regresar al inicio del loop para reevaluar.
    }
    
    bool rescheduleNextDueTimeFlag = false; 
    currentCalculatedSleepDurationS = calculateSleepDuration(
        nextMainDataCollectionDueTimeS_RTC,
        currentUptimeForSleepDecision,
        actualDataIntervalS,
        MIN_SLEEP_S, 
        rescheduleNextDueTimeFlag
    );

    if (rescheduleNextDueTimeFlag) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] RTC target %u was in past or first boot vs uptime %u. Rescheduling next due time.\n",
                        nextMainDataCollectionDueTimeS_RTC, currentUptimeForSleepDecision);
        #endif
        nextMainDataCollectionDueTimeS_RTC = currentUptimeForSleepDecision + actualDataIntervalS;
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] New RTC target: %u. Initial sleep duration based on interval: %lu s.\n", nextMainDataCollectionDueTimeS_RTC, currentCalculatedSleepDurationS);
        #endif
    }
    
    bool useDelayInsteadOfDeepSleepLogic = false; 
    unsigned long customDelayDurationSLogic = 0; 

    useDelayInsteadOfDeepSleepLogic = shouldUseDelayInsteadOfDeepSleep(
        internalTemp,
        actualDataIntervalS,
        currentCalculatedSleepDurationS,
        TEMP_FANS_PRECOOL_MIN_C,
        PRECOOL_DURATION_S,
        AWAKE_PROCESSING_TIME_ESTIMATE_S,
        MIN_SLEEP_S,
        customDelayDurationSLogic
    );

    if (useDelayInsteadOfDeepSleepLogic) {
        #ifdef ENABLE_DEBUG_SERIAL
            Serial.printf("[MainLoop] Using delay (%lu s) instead of deep sleep.\n", customDelayDurationSLogic);
        #endif
        // No desmontar SD ni apagar cámara aquí, ya que no es un deep sleep completo.
        // NVS tampoco se desinicializa aquí.
        delay(customDelayDurationSLogic * 1000);
        // No hay 'return' aquí, el loop se ejecutará de nuevo tras el delay.
    } else {
        // --- Proceder a Deep Sleep ---
        #ifdef ENABLE_DEBUG_SERIAL
            unsigned long awakeTimeThisCycleS_val = (millis() - cycleStartTimeMs) / 1000; 
            Serial.printf("[MainLoop] Awake time this cycle: %lu s. Calculated sleep duration for deep sleep: %lu s.\n", awakeTimeThisCycleS_val, currentCalculatedSleepDurationS);
            Serial.printf("[MainLoop] Next main data collection due at Uptime: %u s.\n", nextMainDataCollectionDueTimeS_RTC);
        #endif

        if (sdManager.isSDAvailable()) { 
            SD_MMC.end(); 
            #ifdef ENABLE_DEBUG_SERIAL
                Serial.println("[MainLoop] SD_MMC unmounted before calling prepareForSleep_Ctrl.");
            #endif
        }

        prepareForSleep_Ctrl(cycleStatusOK, led, camera); // Esto ahora también desinicializa NVS
        deepSleep_Ctrl(currentCalculatedSleepDurationS, &led);
    }
    // --- FIN MODIFICADO ---
}